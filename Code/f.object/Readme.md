# 객체

### package

클래스간의 공간적 충돌이나 접근방법의 충돌을 막기위해

저장위치를 구분하여 명확하게 접근할 수 있도록 해주는 것

보통 네이밍 방법은 회사 도메인을 역으로 입력한다.

ex)

https://www.kh.com일 때

com.kh.팀명(프로젝트명).클래스명

---

### 1. 객체지향 언어

"객체"를 지향하는 언어로 "객체중심"으로 돌아간다. 대표적인 언어가 바로 Java(자바)

### 2. 객체란

현실세계에서 독립적(목적이 있고 가치가 있는 것)으로 존재하는 모든 것을 의미한다.

현실세계에서는 객체들간의 상호작용으로 돌아감.

### 3. 객체지향 프로그래밍

현실세계의 객체들간의 상호작용 

 -> 프로그래밍을 통해서 가상세계로 구현하는 가장 효과적인 방법
   
구현하고자 하는 프로그램상의 필요한 객체들을 만들기 위해서(즉, 생성하기 위해서) 클래스라는 설계도가 먼저 필요하다.

(클래스? 각 객체들의 속성(데이터)들을 담아낼 그릇같은 존재)

### 4. 추상화 과정(중요!)

1) 내가 구현하고자 하는 프로그램에 필요한 객체들을 생각해 볼 것.

2) 그 객체들의 공통적인 속성, 기능들을 추출할 것

3) 추출한 것들을 가지고 내가 구현하고자하는 프로그램의 "실질적인 목적"에 맞춰 불필요한 속성, 기능을 제거할 것

ex) 학생 관리 프로그램

1) 학생관련 객체(최경제훈련생, 최용준훈령생, 안재휘훈련생등등...)

2) 공통적인 속성및 기능(이름, 나이, 주소, 전화번호, 키, 몸무게, 머리색, 발사이즈, 먹는다, 잔다, 공부한다.)

3) 학생 "인적사항"을 관리하는 프로그램 : 이름, 나이, 주소, 전화번호, 반....

학생 "성적"을 관리하는 프로그램 : 이름, 반, 과목별 점수.

학생 "건강"을 관리하는 프로그램 : 이름, 반, 키, 몸무게, 달리기 속도, 먹는다. 휴식한다.

4) 이름 : String name;

나이 : int age;

키  : double height;

### 5.추상화한 객체를 프로그램에 적용시키기

1. "변수"만으로 프로그래밍을 한다.

변수 : 하나의 자료형으로 하나의 값만을 보관할 수 있음.

최경재라는 훈련생 객체 하나 만들기 -> String name1 = "최경재"; int age = 20; double height = 185;

안재휘라는 훈련생 객체 하나 만들기 -> String name2 = "최경재"; int age = 19; double height = 193;

2. 배열로 프로그래밍 한다면

배열 : 하나의 자료형으로 여러개의 값들을 보관할 수 있음.

이름을 보관하는 배열 String[] name = {"최경재", "안재휘"....}

나이를 보관하는 배열 int[] age = {20, 19...}

**값들이 많아지만 가독성이 떨어지는 문제가 생김 -> 그래서 나온 개념 -> 구조체**

**구조체** : 여러개의 자료형의 여러개의 값들을 보관할 수 있다.

String값도 보관하고 int값도 보관하고 동시에 double값도 함께 보관하는 자료형을 직접 만든다고 생각 -> 나만의 자료형

Struct human{

String name;

int age;

double height;

}

-> **자바에서는 구조체 개념을 좀더 확장해서 *클래스*라는 개념을 만들었다.**

---

## 클래스

클래스는 다음과 같은 구조를 가진다.

**접근제한자 class 클래스명 {**


**필드 영역(사용할 데이터를 선언하는 영역)**
		
  String name;//이름
		
  int age; 	//나이
		
  double height;//키

**생성자 영역(데이터를 초기화 해주기위한 특수목적의 메소드를 정의하는 영역)**
		
  public Book(String name, int age, double height) {
		
  this.name,  = name, ; //내가가진(this) name에 넘겨받은 name을 넣는다.
		
  this.age = age;
		
  this.height = height;
	
 }

**메소드 영역(클래스의 기능을 정의하는 영역)**
		
  return "이름 " + " " +this.name +"나이 " + this.age +"키 " + this.height;

---

### 필드

접근제한자 : 해당구조에 접근할 수 있는 범위를 제한한다.

public -> protected -> default -> private

클래스에 사용 가능한 접근제한자 2가지

default public

필드와 메소드에 사용할 수 있는 접근제한자 4가지

**public : 어디서든(같은,다른 패키지 모두)접근 가능**

protecetd : 같은패키지 + 다른패키지일 경우 상속관계

default : 같은패키지 일때만 접근 가능

**private : 오직 해당 클래스에서만 접근 가능**

**public과 private을 많이 쓴다.**

ex)

필드

private String title;//제목

### 생성자 영역

클래스의 이름과 동일한 메소드로 변환형이 없다.

필드 데이터의 초기화를 위한 특수목적의 메소드이다.

매개변수가 하나도 없는 생덩자를 우리는 기본생성자라고합니다.

생성자를 개발자가 직접 만들지 않는다면 컴파일러는 기본생성자를 만들어준다.

개발자가 직접 생성자를 작성하면 기본생성자를 만들어주지 않는다.

메소드이 매개변수의 갯수 또는 타입에 따라서 메소드를 구분하는 메소드 오버로딩은 생성자에도 적용이 된다.


### 메소드 영역

메소드 (class내부에 있는 함수를 우리는 메소드라고 함)

**[표현법]**

**반환형 메소드이름(매개변수){**

**함수에서 실행할 코드**

**}**

매개변수의 갯수 또는 타입이 다르면 메소드를 구분할 수 있다. -> **메소드 오버로딩**

영역안에서 변수를 찾을 때는 가장 작은 단위부터 탐색한다.

**지역변수 우선 -> 이후에 필드값**

this 키워드 사용시 접근한 객체의 필드값을 가져올 수 있다.

**this** -> **인스턴스(메모리를 사용 중인 객체)자기 자신을 의미**

1. 자기 자신의 메모리를 가리킨다. (필드에 있는 걸 가져옴)

2. 생성자에서 다른 생성자를 호출할 수 있따.

3. 자기 자신의 주소를 반환할 수 있다.
